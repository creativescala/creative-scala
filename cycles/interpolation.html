<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Interpolation</title>
    
    
    <meta name="description" content="book" />
    
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script src="../solution.js"></script>
    <script src="../toc.js"></script>
    <script src="../main.js"></script>
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="fun.html">←</a></p>
<p><a href="../../">Creative Scala: Form and Function</a></p>
<p><a href="epicycles.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="../">Creative Scala: Form and Function</a></li>
          <li class="level1 nav-leaf"><a href="../foreword-1.html">Foreword to the First Edition</a></li>
          <li class="level1 nav-leaf"><a href="../foreword-2.html">Foreword to the Second Edition</a></li>
          <li class="level1 nav-node"><a href="../setup/">Getting Started</a></li>
          <li class="level2 nav-leaf"><a href="../setup/background.html">Background</a></li>
          <li class="level2 nav-leaf"><a href="../setup/terminal.html">Installing Terminal Software and a Text Editor</a></li>
          <li class="level2 nav-leaf"><a href="../setup/github.html">GitHub</a></li>
          <li class="level2 nav-leaf"><a href="../setup/intellij.html">IntelliJ</a></li>
          <li class="level2 nav-leaf"><a href="../setup/">Setup</a></li>
          <li class="level1 nav-leaf"><a href="../part-one-introduction.html">Part One: Introduction</a></li>
          <li class="level1 nav-node"><a href="../expressions/">Expressions, Values, and Types</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/02-starting.html">Starting to Program</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/03-expressions.html">Expressions and Values</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/04-types.html">Types</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/05-exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/06-conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../expanding-expressions/">Expanding Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/02-literals.html">Literal Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/03-objects.html">Values are Objects</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/04-types.html">Types</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/05-exercises.html">Exercises</a></li>
          <li class="level1 nav-node"><a href="../expressive-expressions/">Expressive Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/01-images.html">Images</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/02-layout.html">Layout</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/03-color.html">Color</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/04-creating-color.html">Creating Colors</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/05-exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/06-conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../programs/">Writing Larger Programs</a></li>
          <li class="level2 nav-leaf"><a href="../programs/console.html">Working Within the Console</a></li>
          <li class="level2 nav-leaf"><a href="../programs/outside-console.html">Working Without Worksheets</a></li>
          <li class="level2 nav-leaf"><a href="../programs/names.html">Names</a></li>
          <li class="level2 nav-leaf"><a href="../programs/abstraction.html">Abstraction</a></li>
          <li class="level2 nav-leaf"><a href="../programs/imports.html">Packages and Imports</a></li>
          <li class="level1 nav-node"><a href="../substitution/">The Substitution Model of Evaluation</a></li>
          <li class="level2 nav-leaf"><a href="../substitution/substitution.html">Substitution</a></li>
          <li class="level2 nav-leaf"><a href="../substitution/order.html">Order of Evaluation</a></li>
          <li class="level2 nav-leaf"><a href="../substitution/local-reasoning.html">Local Reasoning</a></li>
          <li class="level2 nav-leaf"><a href="../substitution/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../methods/">Methods without Madness</a></li>
          <li class="level2 nav-leaf"><a href="../methods/methods.html">Methods</a></li>
          <li class="level2 nav-leaf"><a href="../methods/syntax.html">Method Syntax</a></li>
          <li class="level2 nav-leaf"><a href="../methods/semantics.html">Method Semantics</a></li>
          <li class="level2 nav-leaf"><a href="../methods/writing-methods.html">Writing Methods</a></li>
          <li class="level2 nav-leaf"><a href="../methods/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../recursion/">Structural Recursion over the Natural Numbers</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/boxes.html">A Line of Boxes</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/natural-numbers.html">The Natural Numbers</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/match.html">Match Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/substitution.html">Reasoning about Recursion</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../fractals/">Fractals</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/fractals.html">Fun with Fractals</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/nested-methods.html">Nested Methods</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/auxillary-parameter.html">Auxiliary Parameters</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../polygons/">Points, Paths, and Polygons</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/02-polar.html">Polar Coordinates</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/03-path.html">Paths</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/04-creative.html">Going Further</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/05-conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../flowers/">Functions and Flowers</a></li>
          <li class="level2 nav-leaf"><a href="../flowers/functions.html">Functions as Abstractions</a></li>
          <li class="level2 nav-leaf"><a href="../flowers/fun.html">Fun with Functions</a></li>
          <li class="level2 nav-leaf"><a href="../flowers/parametric-curves.html">Parametric Curves</a></li>
          <li class="level2 nav-leaf"><a href="../flowers/flowers.html">Flowers and Other Curves</a></li>
          <li class="level2 nav-leaf"><a href="../flowers/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="index.html">Composition and Cycles</a></li>
          <li class="level2 nav-leaf"><a href="composition.html">Function Composition</a></li>
          <li class="level2 nav-leaf"><a href="fun.html">Fun with Composition</a></li>
          <li class="level2 active nav-leaf"><a href="#">Interpolation</a></li>
          <li class="level2 nav-leaf"><a href="epicycles.html">Epicycles</a></li>
          <li class="level2 nav-leaf"><a href="culmination.html">Bringing it Together</a></li>
          <li class="level2 nav-leaf"><a href="conclusions.html">Conclusions</a></li>
          <li class="level1 nav-leaf"><a href="../part-one-conclusions.html">Part One: Conclusions</a></li>
          <li class="level1 nav-header">sequences</li>
          <li class="level2 nav-leaf"><a href="../sequences/lists.html">Working with Lists</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/">Shapes, Sequences, and Stars</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/map.html">Transforming Sequences</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/paths.html">Paths</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/stars.html">My God, It&#39;s Full of Stars!</a></li>
          <li class="level1 nav-header">summary</li>
          <li class="level2 nav-leaf"><a href="../summary/">Summary</a></li>
          <li class="level1 nav-header">animation</li>
          <li class="level2 nav-leaf"><a href="../animation/reactor.html">Reactors</a></li>
          <li class="level2 nav-leaf"><a href="../animation/">Animation and Fireworks</a></li>
          <li class="level2 nav-leaf"><a href="../animation/easing.html">Easing Functions</a></li>
          <li class="level1 nav-leaf"><a href="../links.html">links.md</a></li>
          <li class="level1 nav-header">data</li>
          <li class="level2 nav-leaf"><a href="../data/case-classes.html">Case Classes</a></li>
          <li class="level2 nav-leaf"><a href="../data/">Creating and Working With Data</a></li>
          <li class="level2 nav-leaf"><a href="../data/data.html">Data</a></li>
          <li class="level1 nav-leaf"><a href="../solutions.html">Solutions to Exercises {#solutions}</a></li>
          <li class="level1 nav-header">fp</li>
          <li class="level2 nav-leaf"><a href="../fp/functions.html">Functions as Values</a></li>
          <li class="level2 nav-leaf"><a href="../fp/">(Functional) Programming</a></li>
          <li class="level2 nav-leaf"><a href="../fp/recursion.html">Recursive Algorithms</a></li>
          <li class="level2 nav-leaf"><a href="../fp/take-home-points.html">Take Home Points</a></li>
          <li class="level1 nav-leaf"><a href="../intro.html">Introduction</a></li>
          <li class="level1 nav-header">collections</li>
          <li class="level2 nav-leaf"><a href="../collections/create.html">Creating Sequences</a></li>
          <li class="level2 nav-leaf"><a href="../collections/">Collections {#collections}</a></li>
          <li class="level2 nav-leaf"><a href="../collections/paths.html">Drawing Paths</a></li>
          <li class="level2 nav-leaf"><a href="../collections/transform.html">Transforming Sequences</a></li>
          <li class="level2 nav-leaf"><a href="../collections/take-home-points.html">Take Home Points</a></li>
          <li class="level1 nav-header">declarations</li>
          <li class="level2 nav-leaf"><a href="../declarations/value-declarations.html">Value Declarations</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/">Declarations</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/color-palette.html">Extended Exercise: Color Palettes</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/method-declarations.html">Method Declarations</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/take-home-points.html">Take Home Points</a></li>
          <li class="level1 nav-header">turtles</li>
          <li class="level2 nav-leaf"><a href="../turtles/turtles.html">Controlling the Turtle</a></li>
          <li class="level2 nav-leaf"><a href="../turtles/">Turtle Algebra and Algebraic Data Types</a></li>
          <li class="level2 nav-leaf"><a href="../turtles/branching.html">Branching Structures</a></li>
          <li class="level2 nav-leaf"><a href="../turtles/exercises.html">Exercises</a></li>
          <li class="level1 nav-header">adt</li>
          <li class="level2 nav-leaf"><a href="../adt/turtle.html">Build Your Own Turtle</a></li>
          <li class="level2 nav-leaf"><a href="../adt/adt.html">Algebraic Data Types</a></li>
          <li class="level2 nav-leaf"><a href="../adt/">Algebraic Data Types To Call Our Own</a></li>
          <li class="level1 nav-header">generative</li>
          <li class="level2 nav-leaf"><a href="../generative/random.html">Randomness without Effect</a></li>
          <li class="level2 nav-leaf"><a href="../generative/product.html">Combining Random Values</a></li>
          <li class="level2 nav-leaf"><a href="../generative/">Composition of Generative Art</a></li>
          <li class="level2 nav-leaf"><a href="../generative/api.html">Exploring Random</a></li>
          <li class="level2 nav-leaf"><a href="../generative/generative.html">Generative Art</a></li>
          <li class="level2 nav-leaf"><a href="../generative/exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../generative/flatmap.html">Combining Random Values</a></li>
          <li class="level2 nav-leaf"><a href="../generative/for.html">For Comprehensions</a></li>
          <li class="level1 nav-header">quickreference</li>
          <li class="level2 nav-leaf"><a href="../quickreference/">Syntax Quick Reference {#syntax-quick-reference}</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="interpolation" class="title">Interpolation</h1>
            <p>Our next step is to learn how to create smooth curves connecting points.
            The specific types of curves are known as interpolated splines.
            Interpolation means guessing at a value inbetween points.
            A spline is a specific type of function that will generate the smooth curve.</p>
            <p>The example below sampling between 3 and 15 points from a parametric circle, and interpolating a curve from these points.</p>
            <div class="doodle" id="circle-interpolation"></div>
            <script>CyclesInterpolation.circleInterpolation("circle-interpolation")</script>
            <p>We can see that the curve more closely resembles a circle as we increase the number of points used to create it.</p>
            <p>We use the <code>OpenPath.interpolatingSplice</code> or <code>ClosedPath.interpolatingSpline</code> method to interpolate a curve,
            producing a <code>List[PathElement]</code>. 
            The method expects a <code>List[Point]</code>.
            These lists are types made of two parts. 
            For example, <code>List[Point]</code> consists of</p>
            <ol class="arabic">
              <li><code>List</code>, which is what&#39;s known as a container or collection, meaning it holds other values; and</li>
              <li><code>Point</code>, which is the type of the values inside the list.</li>
            </ol>
            <p>(Notice that all the elements of a list must have the same type.)</p>
            <p>Right now we only need to know how to create lists.
            In later chapters we&#39;ll learn a lot more about how to work with lists and other collections.</p>
            <p>The simplest way to construct a list is by calling the <code>List</code> constructor with the values we want in the list.
            The example below creates a <code>List[Int]</code>, with the elements <code>1</code>, <code>2</code>, and <code>3</code>.</p>
            <pre><code class="nohighlight"><span class="type-name">List</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>)
</span><span class="comment">// res0: List[Int] = List(1, 2, 3)</span></code></pre>
            <p>The order of the elements in the list is important, so the following two lists are different.</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">oneToThree</span><span> = </span><span class="type-name">List</span><span>(</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">threeToOne</span><span> = </span><span class="type-name">List</span><span>(</span><span class="number-literal">3</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">1</span><span>)</span></code></pre>
            <pre><code class="nohighlight"><span class="identifier">oneToThree</span><span> == </span><span class="identifier">threeToOne</span><span>
</span><span class="comment">// res1: Boolean = false</span></code></pre>
            <p>This way of constructing lists requires we know all the elements in advance.
            More often we&#39;ll want to compute the elements as part of our program.
            This is exactly what we&#39;ll be doing here,
            as the elements of the list will be the points from our parametric curve.</p>
            <p>There is a pattern for creating lists an element at a time.
            We either:</p>
            <ul>
              <li>create an empty list, using the expression <code>List.empty</code>; or</li>
              <li>add an element to the front of an existing list, using an expression like <code>anElement :: aList</code>.</li>
            </ul>
            <p>Here&#39;s a quick example, creating the same list as <code>List(1, 2, 3)</code>.</p>
            <pre><code class="nohighlight"><span class="number-literal">1</span><span> :: </span><span class="number-literal">2</span><span> :: </span><span class="number-literal">3</span><span> :: </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
</span><span class="comment">// res2: List[Int] = List(1, 2, 3)</span></code></pre>
            <p>Let&#39;s talk about the expression <code>anElement :: aList</code> a little bit.
            We know that in Scala we always interact with objects using method calls,
            and we can write method calls in two styles:</p>
            <ol class="arabic">
              <li>operator style: <code>1 + 2</code>; or</li>
              <li>normal method call style: <code>1.+(2)</code>.</li>
            </ol>
            <p>There is another rule to operator style.
            A method that ends in a colon (<code>:</code>) is <em>right-associative</em>.
            This means that, in operator style, instead of writing <code>object method parameter</code>
            we write <code>parameter method object</code>.
            So</p>
            <pre><code class="nohighlight"><span class="number-literal">1</span><span> :: </span><span class="number-literal">2</span><span> :: </span><span class="number-literal">3</span><span> :: </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span></code></pre>
            <p>is the same as </p>
            <pre><code class="nohighlight"><span>(</span><span class="number-literal">1</span><span> :: (</span><span class="number-literal">2</span><span> :: (</span><span class="number-literal">3</span><span> :: </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>)))</span></code></pre>
            <p>which is the same as</p>
            <pre><code class="nohighlight"><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>.::(</span><span class="number-literal">3</span><span>).::(</span><span class="number-literal">2</span><span>).::(</span><span class="number-literal">1</span><span>)</span></code></pre>
            <p>Let&#39;s now see a bigger example.
            We will write a method that creates a list of natural numbers.
            This list will have as many elements as the natural number parameter passed to the method.
            The elements will decrease from left to right, ending at zero.</p>
            <p>In other words, the method skeleton is</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">range</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Int</span><span>] =
  ???</span></code></pre>
            <p>and we want results like</p>
            <pre><code class="nohighlight"><span class="identifier">range</span><span>(</span><span class="number-literal">0</span><span>) == </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
</span><span class="identifier">range</span><span>(</span><span class="number-literal">3</span><span>) == </span><span class="type-name">List</span><span>(</span><span class="number-literal">2</span><span>, </span><span class="number-literal">1</span><span>, </span><span class="number-literal">0</span><span>)
</span><span class="identifier">range</span><span>(</span><span class="number-literal">5</span><span>) == </span><span class="type-name">List</span><span>(</span><span class="number-literal">4</span><span>, </span><span class="number-literal">3</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">1</span><span>, </span><span class="number-literal">0</span><span>)</span></code></pre>
            <p>Our first step is to recognize we have a structural recursion over the natural numbers.</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">range</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="identifier">count</span><span> </span><span class="keyword">match</span><span> {
    </span><span class="keyword">case</span><span> </span><span class="number-literal">0</span><span> =&gt; ???
    </span><span class="keyword">case</span><span> </span><span class="identifier">n</span><span> =&gt; ??? </span><span class="identifier">range</span><span>(</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>)
  }</span></code></pre>
            <p>We can use our normal strategies for reasoning about structural recursion,
            alongside the pattern for creating lists.
            Let&#39;s walk through it.</p>
            <p>The first step is to consider each case independently.
            We&#39;ll start with the base case.
            The pattern for creating lists tells us we must either use</p>
            <ul>
              <li><code>List.empty</code>; or</li>
              <li><code>anElement :: aList</code></li>
            </ul>
            <p>In this case the answer is <code>List.empty</code>, 
            which we can tell from the method description.</p>
            <p>Moving to the next case, 
            we have the recursion which produces a <code>List[Int]</code>.
            This suggests we should use the <code>anElement :: aList</code> pattern.
            We might guess that we should write</p>
            <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="identifier">n</span><span> =&gt; </span><span class="identifier">n</span><span> :: </span><span class="identifier">range</span><span>(</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>)</span></code></pre>
            <p>but this will give us a list that ends at 1, not 0.
            The solution is to instead use</p>
            <pre><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="identifier">n</span><span> =&gt; (</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>) :: </span><span class="identifier">range</span><span>(</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>)</span></code></pre>
            <p>This gives us the full solution</p>
            <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">range</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="identifier">count</span><span> </span><span class="keyword">match</span><span> {
    </span><span class="keyword">case</span><span> </span><span class="number-literal">0</span><span> =&gt; </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
    </span><span class="keyword">case</span><span> </span><span class="identifier">n</span><span> =&gt; (</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>) :: </span><span class="identifier">range</span><span>(</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>)
  }</span></code></pre>
            <p>We can check we have the correct solution by comparing the output to the examples above.</p>
            <pre><code class="nohighlight"><span class="comment">// Expect List.empty, also written List()
</span><span class="identifier">range</span><span>(</span><span class="number-literal">0</span><span>) 
</span><span class="comment">// res6: List[Int] = List() 
</span><span>
</span><span class="comment">// Expect List(2, 1, 0)
</span><span class="identifier">range</span><span>(</span><span class="number-literal">3</span><span>)
</span><span class="comment">// res7: List[Int] = List(2, 1, 0)
</span><span>
</span><span class="comment">// Expect List(4, 3, 2, 1, 0)
</span><span class="identifier">range</span><span>(</span><span class="number-literal">5</span><span>) 
</span><span class="comment">// res8: List[Int] = List(4, 3, 2, 1, 0)</span></code></pre>
            <div class="exercise">
              
              <h4 id="exercise-ranging-about">Exercise: Ranging About</h4>
              <p>In the example above the list elements decrease from left to right,
              which is not how we usually order numbers.
              Write an alternative method where the values <em>increase</em> from left to right.</p>
            </div>
            <div class="solution">
              <div class="solution-body">
                <p>We can use the same general structure as <code>range</code>, 
                but we need an auxillary parameter to hold the current value to put into the list.
                We then use a nested method so that the user doesn&#39;t have to deal with this additional parameter.</p>
                <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">rangeReversed</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Int</span><span>] = {
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">loop</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">value</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Int</span><span>] =
    </span><span class="identifier">count</span><span> </span><span class="keyword">match</span><span> {
      </span><span class="keyword">case</span><span> </span><span class="number-literal">0</span><span> =&gt; </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
      </span><span class="keyword">case</span><span> </span><span class="identifier">n</span><span> =&gt; </span><span class="identifier">value</span><span> :: </span><span class="identifier">loop</span><span>(</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>, </span><span class="identifier">value</span><span> + </span><span class="number-literal">1</span><span>)
    }
    
  </span><span class="identifier">loop</span><span>(</span><span class="identifier">count</span><span>, </span><span class="number-literal">0</span><span>)
}</span></code></pre>
                <pre><code class="nohighlight"><span class="identifier">rangeReversed</span><span>(</span><span class="number-literal">0</span><span>)
</span><span class="comment">// res9: List[Int] = List()
</span><span>
</span><span class="identifier">rangeReversed</span><span>(</span><span class="number-literal">3</span><span>)
</span><span class="comment">// res10: List[Int] = List(0, 1, 2)
</span><span>
</span><span class="identifier">rangeReversed</span><span>(</span><span class="number-literal">5</span><span>)
</span><span class="comment">// res11: List[Int] = List(0, 1, 2, 3, 4)</span></code></pre>
              </div>
            </div>
            
            <h2 id="interpolating-parametric-curves" class="section">Interpolating Parametric Curves</h2>
            <p>Now we can put all the pieces together:</p>
            <ol class="arabic">
              <li>sample a <code>List[Point]</code> from a parametric curve; and</li>
              <li>interpolate that <code>List[Point]</code> to produce a smooth curve.</li>
            </ol>
            <p>The first part requires a method, which we&#39;ll call <code>sampleCurve</code>, that is very similar to <code>drawCurve</code> that we&#39;ve used earlier.</p>
            <div class="exercise">
              
              <h4 id="exercise-getting-to-the-point">Exercise: Getting to the Point</h4>
              <p>Implement <code>sampleCurve</code> with the following skeleton</p>
              <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">sampleCurve</span><span>(</span><span class="identifier">points</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">curve</span><span>: </span><span class="type-name">Angle</span><span> =&gt; </span><span class="type-name">Point</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Point</span><span>] =
  ???</span></code></pre>
            </div>
            <div class="solution">
              <div class="solution-body">
                <p>This is a modification of <code>drawCurve</code> that produces a <code>List[Point]</code> instead of an <code>Image</code>.</p>
                <pre><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">sampleCurve</span><span>(</span><span class="identifier">points</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">curve</span><span>: </span><span class="type-name">Angle</span><span> =&gt; </span><span class="type-name">Point</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Point</span><span>] = {
  </span><span class="keyword">val</span><span> </span><span class="identifier">turn</span><span> = </span><span class="type-name">Angle</span><span>.</span><span class="identifier">one</span><span> / </span><span class="identifier">points</span><span>
  </span><span class="keyword">def</span><span> </span><span class="declaration-name">loop</span><span>(</span><span class="identifier">count</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">List</span><span>[</span><span class="type-name">Point</span><span>] =
    </span><span class="identifier">count</span><span> </span><span class="keyword">match</span><span> {
      </span><span class="keyword">case</span><span> </span><span class="number-literal">0</span><span> =&gt; </span><span class="type-name">List</span><span>.</span><span class="identifier">empty</span><span>
      </span><span class="keyword">case</span><span> </span><span class="identifier">n</span><span> =&gt; 
        </span><span class="keyword">val</span><span> </span><span class="identifier">pt</span><span> = </span><span class="identifier">curve</span><span>(</span><span class="identifier">turn</span><span> * </span><span class="identifier">n</span><span>)
        </span><span class="identifier">pt</span><span> :: </span><span class="identifier">loop</span><span>(</span><span class="identifier">n</span><span> - </span><span class="number-literal">1</span><span>)
    }
    
  </span><span class="identifier">loop</span><span>(</span><span class="identifier">points</span><span>)
}</span></code></pre>
              </div>
            </div>
            <p>To do the second part is to create the spline by calling the <code>interpolatingSpline</code>  method on either <code>ClosedPath</code> or <code>OpenPath</code>.
            Remember that closed paths always have a line connecting the end to the start,
            while open paths do not.
            Which you should use depends on the curve you&#39;re drawing.
            If we&#39;re drawing a spiral, for example, an open path is appropriate.
            For a circle we&#39;d use a closed path instead.
            The example below shows this.</p>
            <p><img src="./interpolation.svg" alt="Examples of interpolated curves, with a spiral (an open path) beside a circle (a closed path)." title="Figure Some(#fig:cycles:interpolation): caption"></p>
            <p>This image is created with the code</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">nSamples</span><span> = </span><span class="number-literal">350</span><span>

</span><span class="type-name">Image</span><span>
  .</span><span class="identifier">path</span><span>(
    </span><span class="type-name">OpenPath</span><span>.</span><span class="identifier">interpolatingSpline</span><span>(
      </span><span class="identifier">sampleCurve</span><span>(</span><span class="identifier">nSamples</span><span>, </span><span class="identifier">parametricSpiral</span><span>.</span><span class="identifier">andThen</span><span>(</span><span class="identifier">scale</span><span>(</span><span class="number-literal">100</span><span>)))
    )
  )
  .</span><span class="identifier">beside</span><span>(
    </span><span class="type-name">Image</span><span>
      .</span><span class="identifier">path</span><span>(
        </span><span class="type-name">ClosedPath</span><span>.</span><span class="identifier">interpolatingSpline</span><span>(
          </span><span class="identifier">sampleCurve</span><span>(</span><span class="identifier">nSamples</span><span>, </span><span class="identifier">parametricCircle</span><span>.</span><span class="identifier">andThen</span><span>(</span><span class="identifier">scale</span><span>(</span><span class="number-literal">100</span><span>)))
        )
      )
  )</span></code></pre>
            <div class="exercise">
              
              <h4 id="exercise-the-spline-of-your-life">Exercise: The Spline of Your Life</h4>
              <p>Use <code>sampleCurve</code>, interpolation, and the parametric curves we&#39;ve created earlier to create your own masterpiece.
              In addition to spirals and circles, we have seen rose and Lissajous curves in a previous chapter.</p>
              <p>For many curves, such as a spiral, it&#39;s useful to sample over more than a full turn.
              You might find it useful to add an additional parameter to <code>sampleCurve</code>, to give the angle that should be covered by the samples.</p>
              <p>Below is an example I created using Lissajous curves. (The dashed lines are created using the <code>strokeDash</code> method.) I&#39;m sure you can be a lot more creative.</p>
              <p><img src="./lissajous-stack.svg" alt="Many Lissajous curves stacked atop one another." title="Figure Some(#fig:cycles:lissajous-stack): caption"></p>
            </div>
            <div class="flex flex-row justify-between">
                <a class="pageNavigation" href="fun.html">←Fun with Composition</a> <a class="pageNavigation" href="epicycles.html">Epicycles→</a>
            </div>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>
