<!doctype html>
<html lang="">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Laika 0.19.0" />
    <title>Order of Evaluation</title>
    
    
    <meta name="description" content="book" />
    
    <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:400|Source+Sans+Pro:300,400,600"
        rel="stylesheet" type="text/css">
    <link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400" rel="stylesheet" type="text/css">
    <link rel="stylesheet" type="text/css" href="../creative-scala.css" />
    <script src="../solution.js"></script>
    <script src="../main.js"></script>
    <script> /* for avoiding page load transitions */</script>
</head>

<body>
    <nav id="topbar"><p><a href="substitution.html">←</a></p>
<p><a href="../../">Creative Scala: Form and Function</a></p>
<p><a href="local-reasoning.html">→</a></p></nav>
    <nav id="sidebar">
        <ul class="nav-list">
          <li class="level1 nav-leaf"><a href="../">Creative Scala: Form and Function</a></li>
          <li class="level1 nav-leaf"><a href="../foreword-1.html">Foreword to the First Edition</a></li>
          <li class="level1 nav-leaf"><a href="../foreword-2.html">Foreword to the Second Edition</a></li>
          <li class="level1 nav-node"><a href="../setup/">Getting Started</a></li>
          <li class="level2 nav-leaf"><a href="../setup/background.html">Background</a></li>
          <li class="level2 nav-leaf"><a href="../setup/terminal.html">Installing Terminal Software and a Text Editor</a></li>
          <li class="level2 nav-leaf"><a href="../setup/github.html">GitHub</a></li>
          <li class="level2 nav-leaf"><a href="../setup/intellij.html">IntelliJ</a></li>
          <li class="level2 nav-leaf"><a href="../setup/">Setup</a></li>
          <li class="level1 nav-node"><a href="../expressions/">Expressions, Values, and Types</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/02-starting.html">Starting to Program</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/03-expressions.html">Expressions and Values</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/04-types.html">Types</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/05-exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../expressions/06-summary.html">Summary</a></li>
          <li class="level1 nav-node"><a href="../expanding-expressions/">Expanding Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/02-literals.html">Literal Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/03-objects.html">Values are Objects</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/04-types.html">Types</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/04-images.html">Images</a></li>
          <li class="level2 nav-leaf"><a href="../expanding-expressions/exercises.html">Exercises</a></li>
          <li class="level1 nav-node"><a href="../expressive-expressions/">Expressive Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/02-layout.html">Layout</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/03-color.html">Color</a></li>
          <li class="level2 nav-leaf"><a href="../expressive-expressions/04-creating-color.html">Creating Colors</a></li>
          <li class="level1 nav-node"><a href="index.html">The Substitution Model of Evaluation</a></li>
          <li class="level2 nav-leaf"><a href="substitution.html">Substitution</a></li>
          <li class="level2 active nav-leaf"><a href="#">Order of Evaluation</a></li>
          <li class="level2 nav-leaf"><a href="local-reasoning.html">Local Reasoning</a></li>
          <li class="level1 nav-node"><a href="../methods/">Methods without Madness</a></li>
          <li class="level2 nav-leaf"><a href="../methods/methods.html">Methods</a></li>
          <li class="level2 nav-leaf"><a href="../methods/syntax.html">Method Syntax</a></li>
          <li class="level2 nav-leaf"><a href="../methods/semantics.html">Method Semantics</a></li>
          <li class="level2 nav-leaf"><a href="../methods/writing-methods.html">Writing Methods</a></li>
          <li class="level2 nav-leaf"><a href="../methods/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../recursion/">Structural Recursion over the Natural Numbers</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/boxes.html">A Line of Boxes</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/natural-numbers.html">The Natural Numbers</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/match.html">Match Expressions</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/substitution.html">Reasoning about Recursion</a></li>
          <li class="level2 nav-leaf"><a href="../recursion/conclusions.html">Conclusions</a></li>
          <li class="level1 nav-node"><a href="../fractals/">Fractals</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/fractals.html">The Chessboard</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/nested-methods.html">Nested Methods</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/auxillary-parameter.html">Auxiliary Parameters</a></li>
          <li class="level2 nav-leaf"><a href="../fractals/exercises.html">Exercises</a></li>
          <li class="level1 nav-node"><a href="../polygons/">Points, Paths, and Polygons</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/02-polar.html">Polar Coordinates</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/03-path.html">Paths</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/04-creative.html">Going Further</a></li>
          <li class="level2 nav-leaf"><a href="../polygons/05-conclusions.html">Conclusions</a></li>
          <li class="level1 nav-header">declarations</li>
          <li class="level2 nav-leaf"><a href="../declarations/method-declarations.html">Method Declarations</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/">Declarations</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/value-declarations.html">Value Declarations</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/take-home-points.html">Take Home Points</a></li>
          <li class="level2 nav-leaf"><a href="../declarations/color-palette.html">Extended Exercise: Color Palettes</a></li>
          <li class="level1 nav-header">hof</li>
          <li class="level2 nav-leaf"><a href="../hof/parametric-curves.html">Parametric Curves</a></li>
          <li class="level2 nav-leaf"><a href="../hof/conclusions.html">Conclusions</a></li>
          <li class="level2 nav-leaf"><a href="../hof/">Horticulture and Higher-order Functions</a></li>
          <li class="level2 nav-leaf"><a href="../hof/hof.html">Higher Order Methods and Functions</a></li>
          <li class="level2 nav-leaf"><a href="../hof/exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../hof/flowers.html">Flowers and Other Curves</a></li>
          <li class="level2 nav-leaf"><a href="../hof/functions.html">Functions</a></li>
          <li class="level1 nav-header">sequences</li>
          <li class="level2 nav-leaf"><a href="../sequences/paths.html">Paths</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/stars.html">My God, It&#39;s Full of Stars!</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/">Shapes, Sequences, and Stars</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/lists.html">Working with Lists</a></li>
          <li class="level2 nav-leaf"><a href="../sequences/map.html">Transforming Sequences</a></li>
          <li class="level1 nav-leaf"><a href="../links.html">links.md</a></li>
          <li class="level1 nav-leaf"><a href="../solutions.html">Solutions to Exercises {#solutions}</a></li>
          <li class="level1 nav-header">collections</li>
          <li class="level2 nav-leaf"><a href="../collections/paths.html">Drawing Paths</a></li>
          <li class="level2 nav-leaf"><a href="../collections/">Collections {#collections}</a></li>
          <li class="level2 nav-leaf"><a href="../collections/create.html">Creating Sequences</a></li>
          <li class="level2 nav-leaf"><a href="../collections/take-home-points.html">Take Home Points</a></li>
          <li class="level2 nav-leaf"><a href="../collections/transform.html">Transforming Sequences</a></li>
          <li class="level1 nav-header">turtles</li>
          <li class="level2 nav-leaf"><a href="../turtles/branching.html">Branching Structures</a></li>
          <li class="level2 nav-leaf"><a href="../turtles/">Turtle Algebra and Algebraic Data Types</a></li>
          <li class="level2 nav-leaf"><a href="../turtles/exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../turtles/turtles.html">Controlling the Turtle</a></li>
          <li class="level1 nav-header">programs</li>
          <li class="level2 nav-leaf"><a href="../programs/outside-console.html">Coding Outside the Console</a></li>
          <li class="level2 nav-leaf"><a href="../programs/names.html">Names</a></li>
          <li class="level2 nav-leaf"><a href="../programs/">Writing Larger Programs</a></li>
          <li class="level2 nav-leaf"><a href="../programs/imports.html">Packages and Imports</a></li>
          <li class="level2 nav-leaf"><a href="../programs/abstraction.html">Abstraction</a></li>
          <li class="level2 nav-leaf"><a href="../programs/console.html">Working Within the Console</a></li>
          <li class="level1 nav-header">animation</li>
          <li class="level2 nav-leaf"><a href="../animation/">Animation and Fireworks</a></li>
          <li class="level2 nav-leaf"><a href="../animation/reactor.html">Reactors</a></li>
          <li class="level2 nav-leaf"><a href="../animation/easing.html">Easing Functions</a></li>
          <li class="level1 nav-header">adt</li>
          <li class="level2 nav-leaf"><a href="../adt/">Algebraic Data Types To Call Our Own</a></li>
          <li class="level2 nav-leaf"><a href="../adt/adt.html">Algebraic Data Types</a></li>
          <li class="level2 nav-leaf"><a href="../adt/turtle.html">Build Your Own Turtle</a></li>
          <li class="level1 nav-header">generative</li>
          <li class="level2 nav-leaf"><a href="../generative/generative.html">Generative Art</a></li>
          <li class="level2 nav-leaf"><a href="../generative/">Composition of Generative Art</a></li>
          <li class="level2 nav-leaf"><a href="../generative/flatmap.html">Combining Random Values</a></li>
          <li class="level2 nav-leaf"><a href="../generative/exercises.html">Exercises</a></li>
          <li class="level2 nav-leaf"><a href="../generative/for.html">For Comprehensions</a></li>
          <li class="level2 nav-leaf"><a href="../generative/product.html">Combining Random Values</a></li>
          <li class="level2 nav-leaf"><a href="../generative/random.html">Randomness without Effect</a></li>
          <li class="level2 nav-leaf"><a href="../generative/api.html">Exploring Random</a></li>
          <li class="level1 nav-header">data</li>
          <li class="level2 nav-leaf"><a href="../data/">Creating and Working With Data</a></li>
          <li class="level2 nav-leaf"><a href="../data/case-classes.html">Case Classes</a></li>
          <li class="level2 nav-leaf"><a href="../data/data.html">Data</a></li>
          <li class="level1 nav-leaf"><a href="../intro.html">Introduction</a></li>
          <li class="level1 nav-header">fp</li>
          <li class="level2 nav-leaf"><a href="../fp/">(Functional) Programming</a></li>
          <li class="level2 nav-leaf"><a href="../fp/take-home-points.html">Take Home Points</a></li>
          <li class="level2 nav-leaf"><a href="../fp/recursion.html">Recursive Algorithms</a></li>
          <li class="level2 nav-leaf"><a href="../fp/functions.html">Functions as Values</a></li>
          <li class="level1 nav-header">summary</li>
          <li class="level2 nav-leaf"><a href="../summary/">Summary</a></li>
          <li class="level1 nav-header">quickreference</li>
          <li class="level2 nav-leaf"><a href="../quickreference/">Syntax Quick Reference {#syntax-quick-reference}</a></li>
        </ul>
    </nav>

    <div id="content">
        <main class="content">
            <h1 id="order-of-evaluation" class="title">Order of Evaluation</h1>
            <p>We&#39;re now ready to tackle the question of order-of-evaluation.
            We might wonder if the order of evaluation even matters?
            In the examples we&#39;ve looked at so far the order doesn&#39;t seem to matter, except for the issue that we cannot evaluate an expression before it&#39;s sub-expressions.</p>
            <p>To investigate these issues further we need to introduce a new concept.
            So far we have almost always dealt with <em>pure</em> expressions.
            These are expressions that we can freely substitute in any order without issueFootnote corner-cases.</p>
            <p><em>Impure</em> expressions are those where the order of evaluation matters.
            We have already used one impure expression, the method <code>draw</code>.
            If we evaluate</p>
            <pre><code class="nohighlight"><span class="type-name">Image</span><span>.</span><span class="identifier">circle</span><span>(</span><span class="number-literal">100</span><span>).</span><span class="identifier">draw</span><span>
</span><span class="type-name">Image</span><span>.</span><span class="identifier">rectangle</span><span>(</span><span class="number-literal">100</span><span>, </span><span class="number-literal">50</span><span>).</span><span class="identifier">draw</span></code></pre>
            <p>and</p>
            <pre><code class="nohighlight"><span class="type-name">Image</span><span>.</span><span class="identifier">rectangle</span><span>(</span><span class="number-literal">100</span><span>, </span><span class="number-literal">50</span><span>).</span><span class="identifier">draw</span><span>
</span><span class="type-name">Image</span><span>.</span><span class="identifier">circle</span><span>(</span><span class="number-literal">100</span><span>).</span><span class="identifier">draw</span></code></pre>
            <p>the windows containing the images will appear in different orders.
            Hardly an exciting difference, but it <em>is</em> a difference, which is the point.</p>
            <p>The key distinguishing feature of impure expressions is that their evaluation causes some change that we can see.
            For example, evaluating <code>draw</code> causes an image to be displayed.
            We call these observable changes <em>side effects</em>, or just <em>effects</em> for short.
            In a program containing side effects we cannot freely use substitution.
            However we can use side effects to investigate the order of evaluation.
            Our tool for doing so will be the <code>println</code> method.</p>
            <p>The <code>println</code> method displays text on the console (a side effect) and evaluates to unit.
            Here&#39;s an example:</p>
            <pre><code class="nohighlight"><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;Hello!&quot;</span><span>)
</span><span class="comment">// Hello!</span></code></pre>
            <p>The side-effect of <code>println</code>---printing to the console---gives us a convenient way to investigate the order of evaluation.
            For example, the result of running</p>
            <pre><code class="nohighlight"><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;A&quot;</span><span>)
</span><span class="comment">// A
</span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;B&quot;</span><span>)
</span><span class="comment">// B
</span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;C&quot;</span><span>)
</span><span class="comment">// C</span></code></pre>
            <p>indicates to us that expressions are evaluated from top to bottom.
            Let&#39;s use <code>println</code> to investigate further.</p>
            
            <h3 id="exercises" class="section">Exercises {-}</h3>
            
            <h4 id="no-substitute-for-println" class="section">No Substitute for Println {-}</h4>
            <p>In a pure program we can give a name to any expression and substitute any other occurrences of that expression with the name.
            Concretely, we can rewrite</p>
            <pre><code class="nohighlight"><span>(</span><span class="number-literal">2</span><span> + </span><span class="number-literal">2</span><span>) + (</span><span class="number-literal">2</span><span> + </span><span class="number-literal">2</span><span>)</span></code></pre>
            <p>to</p>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">a</span><span> = (</span><span class="number-literal">2</span><span> + </span><span class="number-literal">2</span><span>)
</span><span class="identifier">a</span><span> + </span><span class="identifier">a</span></code></pre>
            <p>and the result of the program doesn&#39;t change.</p>
            <p>Using <code>println</code> as an example of an impure expression, demonstrates that this is <em>not</em> the case for impure expressions, and hence we can say that impure expressions, or side effects, break substitution.</p>
            <p>&lt;div class=&quot;solution&quot;&gt;
            Here is a simple example that illustrates this.
            The following two programs are observably different.</p>
            <pre><code class="nohighlight"><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;Happy birthday to you!&quot;</span><span>)
</span><span class="comment">// Happy birthday to you!
</span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;Happy birthday to you!&quot;</span><span>)
</span><span class="comment">// Happy birthday to you!
</span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;Happy birthday to you!&quot;</span><span>)
</span><span class="comment">// Happy birthday to you!</span></code></pre>
            <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">happy</span><span> = </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;Happy birthday to you!&quot;</span><span>)
</span><span class="comment">// Happy birthday to you!
</span><span class="identifier">happy</span><span>
</span><span class="identifier">happy</span><span>
</span><span class="identifier">happy</span></code></pre>
            <p>Therefore we cannot freely use substitution in the presence of side effects, and we must be aware of the order of evaluation.
            &lt;/div&gt;</p>
            
            <h4 id="madness-to-our-methods" class="section">Madness to our Methods {-}</h4>
            <p>When we introduced scopes we also introduced block expressions, though we didn&#39;t call them that at the time.
            A block is created by curly braces (<code>{}</code>). It evaluates all the expressions inside the braces. The final result is the result of the last expression in the block.</p>
            <pre><code class="nohighlight"><span class="comment">// Evaluates to three
</span><span>{
  </span><span class="keyword">val</span><span> </span><span class="identifier">one</span><span> = </span><span class="number-literal">1</span><span>
  </span><span class="keyword">val</span><span> </span><span class="identifier">two</span><span> = </span><span class="number-literal">2</span><span>
  </span><span class="identifier">one</span><span> + </span><span class="identifier">two</span><span>
}
</span><span class="comment">// res12: Int = 3</span></code></pre>
            <p>We can use block expressions to investigate the order in which method parameters are evaluated, by putting <code>println</code> expression inside a block that evaluates to some other useful value.</p>
            <p>For example, using <code>Image.rectangle</code> or <code>Color.hsl</code> and block expressions, we can determine if Scala evaluates method parameters in a fixed order, and if so what that order is.</p>
            <p>Note that you can write a block compactly, on one line, by separating expressions with semicolons (<code>;</code>).
            This is generally not good style but might be useful for these experiments.
            Here&#39;s an example.</p>
            <pre><code class="nohighlight"><span class="comment">// Evaluates to three
</span><span>{ </span><span class="keyword">val</span><span> </span><span class="identifier">one</span><span> = </span><span class="number-literal">1</span><span>; </span><span class="keyword">val</span><span> </span><span class="identifier">two</span><span> = </span><span class="number-literal">2</span><span>; </span><span class="identifier">one</span><span> + </span><span class="identifier">two</span><span> }
</span><span class="comment">// res13: Int = 3</span></code></pre>
            <p>&lt;div class=&quot;solution&quot;&gt;
            The following code demonstrates that method parameters are evaluated from left to right.</p>
            <pre><code class="nohighlight"><span class="type-name">Color</span><span>.</span><span class="identifier">hsl</span><span>(
  {
    </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;a&quot;</span><span>)
    </span><span class="number-literal">0</span><span>.</span><span class="identifier">degrees</span><span>
  },
  {
    </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;b&quot;</span><span>)
    </span><span class="number-literal">1.0</span><span>
  },
  {
    </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;c&quot;</span><span>)
    </span><span class="number-literal">1.0</span><span>
  }
)
</span><span class="comment">// a
// b
// c
// res14: Color = HSLA(
//   h = Angle(0.0),
//   s = Normalized(get = 1.0),
//   l = Normalized(get = 1.0),
//   a = Normalized(get = 1.0)
// )</span></code></pre>
            <p>We can write this more compactly as</p>
            <pre><code class="nohighlight"><span class="type-name">Color</span><span>.</span><span class="identifier">hsl</span><span>({ </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;a&quot;</span><span>); </span><span class="number-literal">0</span><span>.</span><span class="identifier">degrees</span><span> },
          { </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;b&quot;</span><span>); </span><span class="number-literal">1.0</span><span> },
          { </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;c&quot;</span><span>); </span><span class="number-literal">1.0</span><span> })
</span><span class="comment">// a
// b
// c
// res15: Color = HSLA(
//   h = Angle(0.0),
//   s = Normalized(get = 1.0),
//   l = Normalized(get = 1.0),
//   a = Normalized(get = 1.0)
// )</span></code></pre>
            <p>&lt;/div&gt;</p>
            
            <h4 id="the-last-order" class="section">The Last Order {-}</h4>
            <p>In what order are Scala expressions evaluated?
            Perform whatever experiments you need to determine an answer to this question to your own satisfaction.
            You can reasonably assume that Scala uses consistent rules across all expressions.
            There aren&#39;t special cases for different expressions.</p>
            <p>&lt;div class=&quot;solution&quot;&gt;
            We&#39;ve already seen that expressions are evaluated from top-to-bottom, and method parameters are evaluated from left-to-right.
            We might want to check that expressions are in general evaluated left-to-right.
            We can show this fairly easily.</p>
            <pre><code class="nohighlight"><span>{ </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;a&quot;</span><span>); </span><span class="number-literal">1</span><span> } + { </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;b&quot;</span><span>); </span><span class="number-literal">2</span><span> } + { </span><span class="identifier">println</span><span>(</span><span class="string-literal">&quot;c&quot;</span><span>); </span><span class="number-literal">3</span><span>}
</span><span class="comment">// a
// b
// c
// res16: Int = 6</span></code></pre>
            <p>So in conclusion we can say that Scala expressions are evaluated from top-to-bottom and left-to-right.
            &lt;/div&gt;</p>
            <table class="footnote">
              <colgroup>
                <col class="label"></col>
                <col></col>
              </colgroup>
              <tbody>
                <tr>
                  <td>[corner-cases]</td>
                  <td>This is not entirely true. There are some corner cases where the order of evaluation does make a difference even with pure expressions. We&#39;re not going to worry about these cases here. If you&#39;re interested in learning more, and this is interesting and useful stuff, you can read up on &quot;eager evaluation&quot; and &quot;lazy evaluation&quot;.</td>
                </tr>
              </tbody>
            </table>
            <p class="nextPage"><a href="local-reasoning.html">Local Reasoning→</a></p>
        </main>
        <footer>Creative Scala is copyright Noel Welsh</footer>
    </div>

    </div>
</body>

</html>
